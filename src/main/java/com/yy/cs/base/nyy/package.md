# 通用通信协议框架（NYY）

----
## 概要

> | *项*     | *详细*           |
> | ---      | ---              |
> | 状态     | 初稿             |
> | 撰写人   | 欧阳柱           |
> | 应用业务 | 精彩世界数据接口 |

目前很多业务和服务的开发过程中，有大量的通信需求，但缺少一种统一的设计思路。导致目前通信在协议形式，依赖技术，实现方式等方面都有较大的差异，重复的工作较多，不利于团队的积累。

这里尝试定义一种通信协议的设计思路，主要目的为简化通信协议的设计，减轻开发工作量，降低沟通的成本。

----
## 思路

- 统一使用UTF-8编码

	- 扁平的数据结构
	- 说明：即尽量以Key-Value的形式来定义通信协议，尽量减少数据结构嵌套的层次。
	- 好处：易于扩展，请求与响应均可以看作是一个Map，可以很简单的通过增加Key来扩展协议

- HTTP作通信承载

	- 说明一：HTTP可以很简单的通过反向代理/DNS等支持Load Balance，Failover。
	- 说明二：HTTP也支持长连接，虽然理论上性能不及一些二进制协议，但大多数业务场景下并不是瓶颈所在。
	- 好处：十分通用的技术，Web前端的Javascript天然支持，其它语言也容易支持。

- JSON作数据封装

	- 说明：也可以使用HTTP的Query String替代JSON，好处是在HTTP GET请求中更易读，坏处是对复杂数据支持不够
	- 好处一：十分通用的技术，Web前端的Javascript天然支持，其它语言也容易支持。
	- 好处二：客户端与服务器端无需严格的依赖，仅需有Key的约定即可。

- 提供通用的安全机制

	- 说明：下面“具体设计”一节会有详细说明
	- 好处：减轻业务在安全方面的工作量

----
## 具体设计

### 协议框架

#### 协议内容

`{"appId":"", "sign":"", "data":{"key1":"value1", "key2":"value2", ... }}`

#### 协议说明

- appId：由服务器端分配给业务端的ID，或是用户的ID（如uid）。
- sign：用于安全校验的Hash（如SHA1），或是UDB的认证Token。
- data：所有的业务数据（建议扁平的Key-Value形式）

### 安全校验

这里的安全校验，是协议层面的安全机制。与其它层面的安全机制并不冲突，而且往往可以形成互补，例如应用级的白名单，机器级的iptables等。

下面列举出几种主要的安全场景供选择，安全级别依次提高。

#### 场景一：无需安全检查
在最简单的场景下，业务可能不需要任务安全检查。此时把appId和sign留空即可。
但仍旧建议保留appId和sign在设计中，一是为将来预留，二是通用的代码支持可以统一支持

#### 场景二：仅需要简单的完整性校验（使用服务器端分配的appId）
//TODO

#### 场景三：仅需要简单的完整性校验（UDB的认证Token）
//TODO

#### 场景四：需要较安全的加密

----
## 通用代码支持（Java）

### TODO：通用代码开发中



